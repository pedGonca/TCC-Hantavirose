data = tb,
type = c("p", "a"))
cloud(visc ~ x1 + x2, data = tb)
# Ajuste do modelo quadrado completo.
m0 <- lm(visc ~ x1 + x2 + I(x1^2) + I(x2^2) + x1:x2,
data = tb)
# AnÃ¡lise dos resÃ­duos.
par(mfrow = c(2, 2))
plot(m0)
graphics::layout(1)
anova(m0)
summary(m0)
delta_x1 <- 2
coef(m0)["x1"]
delta_x2 <- coef(m0)["x2"]/(coef(m0)["x1"]/delta_x1)
delta_x2
names(coef(m0))
b <- cbind(coef(m0)[2:3])
B <- matrix(c(coef(m0)[4],
coef(m0)[6]/2,
coef(m0)[6]/2,
coef(m0)[5]), 2, 2)
-0.5 * solve(B) %*% b # Apanha PJ.
xs <- -0.5 * solve(B, b)    # NÃ£o apanha.
xs
-0.5 * solve(B) %*% b
eigen(B)
library(rsm)
ls("package:rsm")
# Modelo de primeira ordem.
m0 <- rsm(visc ~ FO(x1, x2), data = tb)
summary(m0)
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ FO(x1, x2) + TWI(x1, x2), data = tb)
summary(m0)
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ FO(x1, x2) + TWI(x1, x2) + PQ(x1, x2), data = tb)
summary(m0)
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ SO(x1, x2), data = tb)
summary(m0)
source("~/RStudio Facul/CE074 - Controle de Processos Industriais/CPI-12-superficie-de-resposta.R", echo=TRUE)
# Malha fina para a prediÃ§Ã£o da resposta.
grid_at <- list(x1 = seq(-2.5, 2.5, length.out = 31),
x2 = seq(-2.5, 2.5, length.out = 31))
grid <- as.data.frame(
emmeans::emmeans(m0,
specs = ~x1 + x2,
at = grid_at))
str(grid)
# Uma equaÃ§Ã£o qualquer.
eqn <- expression(
y == beta[0] + beta[1] * x[1] + beta[2] * x[2] +
beta[3] * x[1] * x[2]
)
levelplot(emmean ~ x1 + x2,
data = grid) +
latticeExtra::layer(panel.abline(v = xs[1], h = xs[2]))
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ SO(x1, x2), data = tb)
summary(m0)
tb %>%
distinct(x1, x2, time, temp)
help(codings, help_type = "html")
CR <- coded.data(tb,
x1 ~ (time - 55)/5,
x2 ~ (temp - 165)/5)
CR
code2val(c(x1 = -2.1721279,
x2 = -0.5710768),
codings = codings(CR))
library(latticeExtra)
library(gridExtra)
source(paste0("https://raw.githubusercontent.com/walmes",
"/wzRfun/master/R/panel.3d.contour.R"))
r <- sqrt(2)
da <- rbind(expand.grid(x2 = c(-1, 1), x1 = c(-1, 1)),
data.frame(x1 = 0, x2 = 0)[rep(1, 5), ],
data.frame(x1 = c(r, -r, 0, 0),
x2 = c(0, 0, r, -r)))
db <- rbind(expand.grid(B = c(170, 180), A = c(80, 90)),
data.frame(A = 85, B = 175)[rep(1, 5), ],
data.frame(A = c(92.07, 77.93, 85, 85),
B = c(175, 175, 182.07, 167.93)))
da <- cbind(da, db)
rm("db")
# x <- scan()
# dput(x)
da$y1 <- c(765, 770, 780, 795, 799, 803, 800, 797, 798, 784, 756, 785,
770)/10
da$y2 <- c(62, 60, 66, 59, 72, 69, 68, 70, 71, 68, 71, 58, 57)
da$y3 <- c(2940, 3470, 3680, 3890, 3480, 3200, 3410, 3290, 3500, 3360,
3020, 3630, 3150)
xyplot(A ~ B, data = da)
xyplot(x1 ~ x2, data = da, aspect = "iso", pch = 19) +
layer(panel.segments(c(-r, 0),
c(0, -r),
c(r, 0),
c(0, r),
col = 1, lty = 2)) +
layer(panel.lines(c(-1, 1, 1, -1, -1),
c(-1, -1, 1, 1, -1),
col = 1, lty = 2))
m0 <- lm(y1 ~ x1 + x2 + x1:x2 + I(x1^2) + I(x2^2),
data = da)
coef(m0)
summary(m0)
pred <- expand.grid(x1 = seq(-r, r, length.out = 20),
x2 = seq(-r, r, length.out = 20))
pred$y1 <- predict(m0, newdata = pred)
wireframe(y1 ~ x1 + x2, data = pred,
panel.3d.wireframe = panel.3d.contour,
type = "on",
drape = TRUE)
levelplot(y1 ~ x1 + x2, data = pred, contour = TRUE)
# Coeficientes de primeira ordem.
b <- cbind(coef(m0)[2:3])
# Coeficientes de segunda ordem.
B <- matrix(0, 2, 2)
diag(B) <- coef(m0)[4:5]
B[2, 1] <- coef(m0)[6]/2
B[1, 2] <- coef(m0)[6]/2
b
B
# Coordenada do ponto estacionÃ¡rio.
# xs <- -0.5 * solve(B) %*% b
xs <- -0.5 * solve(B, b)
levelplot(y1 ~ x1 + x2, data = pred, contour = TRUE) +
layer(panel.abline(v = xs[1], h = xs[2], lty = 2)) +
layer(panel.points(xs[1], xs[2], pch = 19, col = "red"))
# Estudo da concavidade pelo sinal dos autovalores.
eigen(B)
# Ponto estÃ¡cionÃ¡rio na escala natural.
(xs[1] * 5) + 85
(xs[2] * 5) + 185
# Coeficientes de primeira ordem.
b <- cbind(coef(m0)[2:3])
# Coeficientes de segunda ordem.
B <- matrix(0, 2, 2)
diag(B) <- coef(m0)[4:5]
B[2, 1] <- coef(m0)[6]/2
B[1, 2] <- coef(m0)[6]/2
# Coordenada do ponto estacionÃ¡rio.
# xs <- -0.5 * solve(B) %*% b
xs <- -0.5 * solve(B, b)
levelplot(y1 ~ x1 + x2, data = pred, contour = TRUE) +
layer(panel.abline(v = xs[1], h = xs[2], lty = 2)) +
layer(panel.points(xs[1], xs[2], pch = 19, col = "red"))
# Estudo da concavidade pelo sinal dos autovalores.
eigen(B)
coef(m0)[2:3]
summary(m0)
# Coeficientes de segunda ordem.
B <- matrix(0, 2, 2)
diag(B) <- coef(m0)[4:5]
B[2, 1] <- coef(m0)[6]/2
B[1, 2] <- coef(m0)[6]/2
B
# Coordenada do ponto estacionÃ¡rio.
# xs <- -0.5 * solve(B) %*% b
xs <- -0.5 * solve(B, b)
xs
rm(list = ls())
# ImportaÃ§Ã£o.
url <- "http://leg.ufpr.br/~walmes/data/MontgomeryASPE5th/Example14.12.txt"
tb <- read.table(url, header = TRUE, sep = "\t")
# Nomes curtos e caixa baixa.
names(tb) <- tolower(substr(names(tb), 1, 4))
str(tb)
# CombinaÃ§Ãµes dos fatores experimentais.
xtabs(~x1 + x2, data = tb)
# Ã um CCD (central composite design).
xyplot(x2 ~ x1,
data = tb)
xyplot(visc ~ x1,
data = tb,
type = c("p", "a"))
xyplot(visc ~ x2,
data = tb,
type = c("p", "a"))
cloud(visc ~ x1 + x2, data = tb)
# Ajuste do modelo quadrado completo.
m0 <- lm(visc ~ x1 + x2 + I(x1^2) + I(x2^2) + x1:x2,
data = tb)
# AnÃ¡lise dos resÃ­duos.
par(mfrow = c(2, 2))
plot(m0)
graphics::layout(1)
anova(m0)
summary(m0)
delta_x1 <- 2
coef(m0)["x1"]
delta_x2 <- coef(m0)["x2"]/(coef(m0)["x1"]/delta_x1)
delta_x2
names(coef(m0))
b <- cbind(coef(m0)[2:3])
B <- matrix(c(coef(m0)[4],
coef(m0)[6]/2,
coef(m0)[6]/2,
coef(m0)[5]), 2, 2)
-0.5 * solve(B) %*% b # Apanha PJ.
xs <- -0.5 * solve(B, b)    # NÃ£o apanha.
xs
-0.5 * solve(B) %*% b
eigen(B)
xs
tb %>%
distinct(x1, x2, time, temp)
tb %>%
distinct(x1, x2, time, temp)
# ImportaÃ§Ã£o.
url <- "http://leg.ufpr.br/~walmes/data/MontgomeryASPE5th/Example14.12.txt"
tb <- read.table(url, header = TRUE, sep = "\t")
# Nomes curtos e caixa baixa.
names(tb) <- tolower(substr(names(tb), 1, 4))
str(tb)
# CombinaÃ§Ãµes dos fatores experimentais.
xtabs(~x1 + x2, data = tb)
# Ã um CCD (central composite design).
xyplot(x2 ~ x1,
data = tb)
xyplot(visc ~ x1,
data = tb,
type = c("p", "a"))
xyplot(visc ~ x2,
data = tb,
type = c("p", "a"))
cloud(visc ~ x1 + x2, data = tb)
# Ajuste do modelo quadrado completo.
m0 <- lm(visc ~ x1 + x2 + I(x1^2) + I(x2^2) + x1:x2,
data = tb)
# AnÃ¡lise dos resÃ­duos.
par(mfrow = c(2, 2))
plot(m0)
graphics::layout(1)
# ImportaÃ§Ã£o.
url <- "http://leg.ufpr.br/~walmes/data/MontgomeryASPE5th/Example14.12.txt"
tb <- read.table(url, header = TRUE, sep = "\t")
# Nomes curtos e caixa baixa.
names(tb) <- tolower(substr(names(tb), 1, 4))
str(tb)
# CombinaÃ§Ãµes dos fatores experimentais.
xtabs(~x1 + x2, data = tb)
# Ã um CCD (central composite design).
xyplot(x2 ~ x1,
data = tb)
xyplot(visc ~ x1,
data = tb,
type = c("p", "a"))
xyplot(visc ~ x2,
data = tb,
type = c("p", "a"))
cloud(visc ~ x1 + x2, data = tb)
# Ajuste do modelo quadrado completo.
m0 <- lm(visc ~ x1 + x2 + I(x1^2) + I(x2^2) + x1:x2,
data = tb)
# AnÃ¡lise dos resÃ­duos.
par(mfrow = c(2, 2))
plot(m0)
graphics::layout(1)
anova(m0)
summary(m0)
delta_x1 <- 2
coef(m0)["x1"]
delta_x2 <- coef(m0)["x2"]/(coef(m0)["x1"]/delta_x1)
delta_x2
names(coef(m0))
b <- cbind(coef(m0)[2:3])
B <- matrix(c(coef(m0)[4],
coef(m0)[6]/2,
coef(m0)[6]/2,
coef(m0)[5]), 2, 2)
-0.5 * solve(B) %*% b # Apanha PJ.
xs <- -0.5 * solve(B, b)    # NÃ£o apanha.
xs
-0.5 * solve(B) %*% b
eigen(B)
summary(tb[, c("x1", "x2")])
# Malha fina para a prediÃ§Ã£o da resposta.
grid_at <- list(x1 = seq(-2.5, 2.5, length.out = 31),
x2 = seq(-2.5, 2.5, length.out = 31))
tb %>%
distinct(x1, x2, time, temp)
library(tidyverse)
tb %>%
distinct(x1, x2, time, temp)
(170 - 160)/2
xs[1]
summary(m0)
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ SO(x1, x2), data = tb)
summary(m0)
library(rsm)
ls("package:rsm")
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ SO(x1, x2), data = tb)
summary(m0)
xs[1]
tb %>%
distinct(x1, x2, time, temp)
tb %>%
distinct(x1, x2, time, temp)
(xs[1] - 5) + pm
#-----------------------------------------------------------------------
xs
pm <- 165 -- Ponto médio
am <- 5   -- Amplitude média
(xs[1] - 5) + pm
pm <- 165 ## Ponto médio
am <- 5   ## Amplitude média
(xs[1] - 5) + pm
CR <- coded.data(tb,
x1 ~ (time - 55)/5,
x2 ~ (temp - 165)/5)
CR
code2val(c(x1 = -2.1721279,
x2 = -0.5710768),
codings = codings(CR))
#-----------------------------------------------------------------------
xs
pm <- 165 ## Ponto médio
am <- 5   ## Amplitude média
(xs[1] - 5) + pm
xs[1]
(xs[2] - 5) + pm
#-----------------------------------------------------------------------
xs
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ SO(x1, x2), data = tb)
summary(m0)
tb %>%
distinct(x1, x2, time, temp)
pm <-
165 ## Ponto médio
#-----------------------------------------------------------------------
xs
pm <- 165 ## Ponto médio
am <- 5   ## Amplitude média
(xs[2] - 5) + pm
r <- sqrt(2)
da <- rbind(expand.grid(x2 = c(-1, 1), x1 = c(-1, 1)),
data.frame(x1 = 0, x2 = 0)[rep(1, 5), ],
data.frame(x1 = c(r, -r, 0, 0),
x2 = c(0, 0, r, -r)))
db <- rbind(expand.grid(B = c(170, 180), A = c(80, 90)),
data.frame(A = 85, B = 175)[rep(1, 5), ],
data.frame(A = c(92.07, 77.93, 85, 85),
B = c(175, 175, 182.07, 167.93)))
da <- cbind(da, db)
rm("db")
# x <- scan()
# dput(x)
da$y1 <- c(765, 770, 780, 795, 799, 803, 800, 797, 798, 784, 756, 785,
770)/10
da$y2 <- c(62, 60, 66, 59, 72, 69, 68, 70, 71, 68, 71, 58, 57)
da$y3 <- c(2940, 3470, 3680, 3890, 3480, 3200, 3410, 3290, 3500, 3360,
3020, 3630, 3150)
xyplot(A ~ B, data = da)
xyplot(x1 ~ x2, data = da, aspect = "iso", pch = 19) +
layer(panel.segments(c(-r, 0),
c(0, -r),
c(r, 0),
c(0, r),
col = 1, lty = 2)) +
layer(panel.lines(c(-1, 1, 1, -1, -1),
c(-1, -1, 1, 1, -1),
col = 1, lty = 2))
m0 <- lm(y1 ~ x1 + x2 + x1:x2 + I(x1^2) + I(x2^2),
data = da)
coef(m0)
summary(m0)
pred <- expand.grid(x1 = seq(-r, r, length.out = 20),
x2 = seq(-r, r, length.out = 20))
pred$y1 <- predict(m0, newdata = pred)
wireframe(y1 ~ x1 + x2, data = pred,
panel.3d.wireframe = panel.3d.contour,
type = "on",
drape = TRUE)
levelplot(y1 ~ x1 + x2, data = pred, contour = TRUE)
# Coeficientes de primeira ordem.
b <- cbind(coef(m0)[2:3])
# Coeficientes de segunda ordem.
B <- matrix(0, 2, 2)
diag(B) <- coef(m0)[4:5]
B[2, 1] <- coef(m0)[6]/2
B[1, 2] <- coef(m0)[6]/2
# Coordenada do ponto estacionÃ¡rio.
# xs <- -0.5 * solve(B) %*% b
xs <- -0.5 * solve(B, b)
# Estudo da concavidade pelo sinal dos autovalores.
eigen(B)
tb %>%
distinct(x1, x2, time, temp)
da
library(lattice)
library(latticeExtra)
library(plotly)
library(shiny)
library(tidyverse)
plotly_surface <- function(grid) {
fig_sur <-
plot_ly(
x = grid$x1,
y = grid$x2,
z = grid$fit,
colors = "viridis") %>%
add_surface(
contours = list(
z = list(
show = TRUE,
usecolormap = TRUE,
highlightcolor = "#ff0000",
project = list(z = TRUE)
)
)
) %>%
colorbar(title = "y") %>%
layout(
scene = list(
aspectratio = list(x = 1, y = 1, z = 0.5),
xaxis = list(title = "x1",
range = c(-1, 1)),
yaxis = list(title = "x2",
range = c(-1, 1)),
zaxis = list(title = "y",
range = c(-10, 10)))
)
fig_sur
}
rm(list = ls())
# ImportaÃ§Ã£o.
url <- "http://leg.ufpr.br/~walmes/data/MontgomeryASPE5th/Example14.12.txt"
tb <- read.table(url, header = TRUE, sep = "\t")
# Nomes curtos e caixa baixa.
names(tb) <- tolower(substr(names(tb), 1, 4))
str(tb)
# CombinaÃ§Ãµes dos fatores experimentais.
xtabs(~x1 + x2, data = tb)
# Ã um CCD (central composite design).
xyplot(x2 ~ x1,
data = tb)
xyplot(visc ~ x1,
data = tb,
type = c("p", "a"))
xyplot(visc ~ x2,
data = tb,
type = c("p", "a"))
cloud(visc ~ x1 + x2, data = tb)
# Ajuste do modelo quadrado completo.
m0 <- lm(visc ~ x1 + x2 + I(x1^2) + I(x2^2) + x1:x2,
data = tb)
# AnÃ¡lise dos resÃ­duos.
par(mfrow = c(2, 2))
plot(m0)
graphics::layout(1)
anova(m0)
summary(m0)
delta_x1 <- 2
coef(m0)["x1"]
delta_x2 <- coef(m0)["x2"]/(coef(m0)["x1"]/delta_x1)
delta_x2
names(coef(m0))
b <- cbind(coef(m0)[2:3])
B <- matrix(c(coef(m0)[4],
coef(m0)[6]/2,
coef(m0)[6]/2,
coef(m0)[5]), 2, 2)
-0.5 * solve(B) %*% b # Apanha PJ.
xs <- -0.5 * solve(B, b)    # NÃ£o apanha.
xs
-0.5 * solve(B) %*% b
eigen(B)
library(rsm)
ls("package:rsm")
# Modelo de primeira ordem com interaÃ§Ã£o.
m0 <- rsm(visc ~ SO(x1, x2), data = tb)
summary(m0)
devtools::install_github("https://github.com/ramoswillian/xaringan")
install.packages('devtools')
install.packages("devtools")
devtools::install_github("https://github.com/ramoswillian/xaringan")
install.packages('mktexlsr')
install.packages("tinytex")
install.packages("tinytex")
install.packages("colortbl")
install.packages("lmodern")
library(rmarkdown)
draft(file = "Projeto.Rmd", template = "tcc-template",
package = "tcctemplate", create_dir = TRUE, edit = FALSE)
remotes::install_github("fernandomayer/tcctemplate")
remotes::install_github("fernandomayer/tcctemplate", force = TRUE)
setwd("~/RStudio Facul/CE094 - Laboratório B/tcc-hantavirose/Template TCC")
citation()
citation()
version
citation()
citation(smcure)
citation("smcure")
citation("survival")
toBibtex(survival)
toBibtex("survival")
?survival
?survival
?survfit
install.packages("survival")
install.packages("survival")
?survfit
?survival
?survfit
?survival
?survfit
citation("survival")
